# auto-generated by grc.converter

id: mapper_preamble_sync_demapper
label: Decode using Preamble Synch
category: '[mapper]'

parameters:
-   id: width
    label: Width
    dtype: int
-   id: preamble
    label: Preamble
    dtype: int_vector
-   id: modtype
    label: Modulaton
    dtype: enum
    options: [mapper.BPSK, mapper.P2BPSK, mapper.QPSK, mapper.PSK8]
    option_labels: [BPSK, Pi/2BPSK, QPSK, 8PSK]
-   id: symbol_map
    label: Symbol Values
    dtype: int_vector
    default: '[0,1]'
-   id: acquire_bit_thresh
    label: Bits for Acquire Trigger
    dtype: int
    default: '0'
-   id: loose_bit_thresh
    label: Bits for Loss of Sync
    dtype: int
    default: '3'
-   id: passthrough
    label: Preamble Pass-through
    dtype: enum
    options: ['True', 'False']
    option_labels: ['Yes', 'No']

inputs:
-   domain: stream
    dtype: complex

outputs:
-   domain: stream
    dtype: float

templates:
    imports: import mapper
    make: mapper.preamble_sync_demapper(${width}, ${preamble}, ${modtype}, ${symbol_map},
        ${acquire_bit_thresh}, ${loose_bit_thresh}, ${passthrough})

documentation: "Assumes there is only 1 sample per symbol\n\n      Bits for Acquire\
    \ Trigger - # of bits that are wrong for this condition to be met (0 means exact\
    \ preamble found)\n      Bits for Loose Trigger - # of bits that are wrong for\
    \ this condition to be met (3 bits wrong)\n      Width - # of bits in each block\
    \ including the length of the preamble\n      Preamble - Create a variable in\
    \ grc that uses the built in Preamble_Gen function (see below)\n        \n   \
    \     pream_len = 84\n        preamble = (mapper.preamble_generator(pream_len,511,1033)).get_preamble()\n\
    \                                             (length,  seed, mask)"

file_format: 1
